<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Rubberband : Rubberband: A small, flexible language">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Rubberband</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/romariorios/rubberband">View on GitHub</a>

          <h1 id="project_title">Rubberband</h1>
          <h2 id="project_tagline">Rubberband: A small, flexible language</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/romariorios/rubberband/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/romariorios/rubberband/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>Rubberband is a very minimalistic and customizable experimental programming
language. This manual introduces the language's goals and characteristics and,
then, presents it in more detail. This document tries to aim at the newest
version of Rubberband, but the language is not finished yet and it is constantly
changing, so, at the moment you're reading this, the document may be outdated
when compared to the actual implementation -- so beware.</p>

<h1>
<a id="building" class="anchor" href="#building" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building</h1>

<p>The current project consists of the core library <code>librubberband</code> and the
reference interpreter <code>rbbs</code> (stands for <strong>r</strong>ub<strong>b</strong>er<strong>b</strong>and <strong>s</strong>cript).
Throughout the entirety of this manual, it is assumed that all examples are ran
as scripts from the <code>rbbs</code> program.</p>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>Currently, the dependencies to build Rubberband are:</p>

<ul>
<li>CMake (&gt;= 2.8)</li>
<li>Make</li>
<li>g++ and gcc (&gt;= 4.8) or clang (&gt;= 3.3)</li>
</ul>

<p>No extra dependencies are needed. Note that it's possible that it works in a
different configuration -- e.g., a newer version of clang or gcc --, but it has
never been tested.</p>

<h2>
<a id="compiling-rbbs" class="anchor" href="#compiling-rbbs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling rbbs</h2>

<p>If you just want to build and run <code>rbbs</code>, from inside the <code>src</code> subdirectory of
the repository, run:</p>

<pre><code>cmake . &amp;&amp; make
</code></pre>

<p>The <code>rbbs</code> executable will be found at the <code>rbbs</code> subdir and then you can just
use it, passing the .rbb script as an argument. You can find examples in the
<code>codeexamples</code> directory in the repository -- there are two at the moment of
this writing.</p>

<p>For more info on how to use CMake, check out its own documentation.</p>

<h2>
<a id="running-tests" class="anchor" href="#running-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running tests</h2>

<p>You can also run the tests of the <code>librubberband</code> library. There's a
<code>runtests.sh</code> script inside the <code>src/test</code> dir, which can be run from any fairly
recent version of Bash. The following variables are used:</p>

<ul>
<li>
<code>CXX</code>: The c++ compiler</li>
<li>
<code>CXX_FLAGS</code> (default: <code>"-g -O0"</code> when CXX is either g++ or clang++): Flags
passed to the compiler </li>
<li>
<code>THREADS</code> (default: 1): Number of threads of the compilation process</li>
<li>
<code>TESTS</code> (default: all): Tests which will be run</li>
<li>
<code>RUBBERBAND_SRC</code> (default: <code>$PWD/../core</code>): Directory of rubberband's core
library source code</li>
</ul>

<h1>
<a id="language-overview" class="anchor" href="#language-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Language Overview</h1>

<p>This section will give an overview of the goals and the characteristics of
Rubberband.</p>

<h2>
<a id="design-goals" class="anchor" href="#design-goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Goals</h2>

<p>The Rubberband programming language is an experimental programming language
created with the main objective of being as customizable by the developer as
possible. Currently, the main design goals of Rubberband are:</p>

<ul>
<li>
<strong>Core minimalism</strong>: having <em>just a few basic elements</em> instead of putting many
features inside the core of the language makes it easier to build its features
-- and the ones needed by the developer -- from the ground up, avoiding
the redundancy of core language constructs.</li>
<li>
<strong>Orthogonality</strong>: to provide the developer the flexibility for them to
customize the language, it needs <em>allow composition</em> between most elements of
the language <em>in a way that makes sense</em>.</li>
<li>
<strong>Explicitness</strong>: hidden or implicit elements or mechanisms in the language
creates elements which, being out of reach from the runtime, cannot be
directly customized -- thus, <em>explicitness increases the customizability of
the language</em>.</li>
<li>
<strong>Conciseness</strong>: although making a language concise solely to save keystrokes
is considered a bad idea, since it may hurt readability, too much verbosity
may also make the code hard to follow. Since the language is supposed to
be explicit, many basic expressions will be visible in the code -- <em>making all
these expressions too long leads to verbose code</em>, which can sacrifice
readability more than conciseness. Aside from that, avoiding to use reserved
words like "if", "for", "while" and others in favor of symbols like "$", "@",
"~", etc. leaves room for the developer use the former for their own purposes.</li>
<li>
<strong>Freedom (and responsibility) to the developer</strong>: the core Rubberband
language intends to define as little policies and follow as little conventions
as possible, because one of its goals is to <em>give the developer the ability to
define their own conventions and policies</em>. This comes from the idea defining
coding style, conventions, the design patterns in use and other kinds of
project policies is a job of the <em>framework</em> not one of the language, which
should only be concerned in providing the constructs necessary to express
those policies. That's why <strong>minimalism</strong> is also one of its core design
goals: the core language is intended to provide a flexible foundation from
which developers can develop their own frameworks, and having core features
beyond the very basic will interfere with that.</li>
</ul>

<p>There can be many more considerations on the design goals of Rubberband, but
those described above are enough to give an idea of why the language is like
it is.</p>

<h2>
<a id="characteristics" class="anchor" href="#characteristics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Characteristics</h2>

<p>Now that the design goals have been set, the actual characteristics of the
latest implementation will be described. Rubberband is:</p>

<ul>
<li>
<strong>Purely object-oriented</strong>: object-orientation is a concept which needs no
introduction. However, <em>pure</em> in this context means that every value in the
language is an object. There are some languages in which this isn't the case,
i.e. not all values are objects -- namely, <em>C++</em> and <em>Java</em>. That's why this
distinction is made.</li>
<li>
<strong>Message-based</strong>: unlike many object-oriented languages, though --
languages like <em>C++</em>, <em>Java</em>, etc. --, Rubberband is based on <em>message passing</em>
instead of function calling. This makes it more similar to <em>Smalltalk</em> and
other languages which inherited this characteristic from it, like <em>Object C</em>
and <em>Ruby</em>, for instance. But, unlike Smalltalk, messages do not have
arguments attached to them in Rubberband. More on that later.</li>
<li>
<strong>Classless</strong>: One more thing that sets Rubberband apart from Smalltalk,
though, is that it doesn't have classes -- at least, not as a concept built in
the language. Most object-oriented languages implement a class vs instance or
object duality, that is, every object is necessarily an instance of a class --
which may or may not be an object itself, depending on the language. In
Rubberband, though, objects are standalone and don't need a class to exist --
although the programmer can inquire on what <em>type</em> of object it's dealing
with. In that regard, Rubberband is closer to languages like <em>Self</em>, <em>Lua</em>,
<em>Javascript</em>, <em>Io</em>, etc.. Languages like those are also referred to as
<em>prototype-based</em> languages.</li>
<li>
<strong>Reflexive</strong>: All of the basic objects of the language offer reflection
capabilities which enable the developer to query metainformation about an
object; they can query the type of the object and if a given message is valid.</li>
<li>
<strong>Duck-typed</strong>: Duck typing is a concept common in dynamic languages
like <em>Python</em> and <em>Ruby</em>. Like in those languages, in Rubberband, if an object
behaves like you want it to in the context you're using, then, for all
practical intents, it's the object you want. Without duck typing, the
programmer is required to check if the type of the object is the right type.</li>
</ul>

<h1>
<a id="language-presentation" class="anchor" href="#language-presentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Language Presentation</h1>

<p>The previous section only passed by the features of the Rubberband, comparing
them with similar features in other languages. This section will present the
language and show its features on their own.</p>

<h2>
<a id="objects" class="anchor" href="#objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objects</h2>

<p>As seen before, Rubberband is a purely object-oriented, message-based,
classless, reflexive, duck typed, experimental programming language. As a
purely object-oriented language, the <em>object</em> is everywhere in the program.
The basic objects present in the language are:</p>

<ul>
<li>
<strong>Numbers</strong>: <code>10</code>, <code>200.555</code>, <code>-3</code>, <code>0</code>
</li>
<li>
<strong>Symbols</strong>, used to name variables, functions, operations, fields, etc..
Basically, identifiers: <code>a</code>, <code>while</code>, <code>+</code>, etc.</li>
<li>
<strong>The empty object</strong>, denoted <code>()</code>, used to indicate the absence of a value</li>
<li>
<strong>Booleans</strong>: <code>?1</code> and <code>?0</code> (true and false, respectively)</li>
<li>
<strong>Arrays</strong>. They start with <code>|</code>, are separated by commas and accept any
object as an element -- but are not resizable: <code>|10, 20, 30</code>,
<code>|a, 10, (|10, 20, 30), ?1</code>
</li>
<li>
<strong>Tables</strong>, which map symbols to functions. They start with <code>:</code>, followed
by the symbol-object pairs, separated by commas: <code>:a -&gt; 10, b -&gt; 20, c -&gt; 30</code>,
<code>:yes -&gt; ?1, twelve -&gt; 12</code>,
<code>:list -&gt; (|2, 3, 5, 7), table -&gt; (:happy -&gt; ?1, age -&gt; 25)</code>
</li>
<li>
<strong>Blocks</strong> of code. They are first-class citizens in Rubberband, so, just
like arrays or a numbers, they can be put inside a table, an array, etc..
They're enclosed between curly braces, whithin which the code is defined;
currently, the code contained inside a Rubberband script file defines a block
object, the only difference being the lack of curly braces. More details on
blocks will be given in the following section.</li>
</ul>

<h2>
<a id="messages-and-answers" class="anchor" href="#messages-and-answers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Messages and answers</h2>

<p>Rubberband is a message-based message. This means that the programmer gets
information and modifies the state of an object by sending messages to it.
A message to an object can be any other object; to send a message, the
programmer just needs to put the message at the side of the object.</p>

<p>For example, suppose you store an array in a variable called <code>arr</code> like this:</p>

<pre><code>~:arr -&gt; |10, 20, 30, 40
</code></pre>

<p>Arrays are zero-indexed in rubberband; so, to get the third element in the
array -- which is 30 --, you would send the number <code>2</code> to the variable <code>arr</code>:</p>

<pre><code>~:third_element -&gt; ~arr 2
</code></pre>

<p>In the above example, the message <code>2</code> is being sent to the variable <code>arr</code>.
As a reaction to receiving this message, the array gives an <em>answer</em>, which is,
in this case, the third element of the array. There are two ways in which an
object can react to a message: it either gives an answer or it causes a runtime
error if the object doesn't respond to that message. For example, if you sent
<code>4</code> instead of <code>2</code> to <code>arr</code>, since that index is out of range, that would
generate a runtime error:</p>

<pre><code>terminate called after throwing an instance of 'rbb::in_statement_error'
  what(): In statement "~ arr 4": When sending message 4 to object (|10, 20, 30, 40): Message not recognized
</code></pre>

<p>Of course, to send a second message to the answer of a message send, just place
the second message at the right side of the first one, and the same for any
subsequent messages. For example:</p>

<pre><code>~:nested -&gt; 1, (|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13), 14
~:number -&gt; ~nested 1 2 3 4
</code></pre>

<p>Let's interpret the above expression step by step: first, the number <code>1</code> is sent
to <code>nested</code> -- the answer is the second element of the array, that is,
<code>|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13</code>. Then, to that object, the
number <code>2</code> is sent, to which the third element -- that is,
<code>|4, 5, 6, (|7, 8, 9, 10, 11), 12</code> -- is given as the answer. From that, the
array <code>|7, 8, 9, 10, 11</code> is given as an answer to the message <code>3</code>, to which,
finally, the message <code>4</code> is sent, giving is the value of the full expression:
<code>11</code>, the fifth element of the array.</p>

<p>The message send is the only operation in Rubberband. Anything -- arithmetic,
control flow, accessing array elements, and other operations -- is done by
sending messages to objects. Here are some examples on how that works.</p>

<h3>
<a id="variable-assignment-and-access" class="anchor" href="#variable-assignment-and-access" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variable assignment and access</h3>

<p>The message send is the only operation in the language, so, even when the
programming is, say, creating or accessing the value of a variable, they are
sending a message to an object.</p>

<p>You might have noticed that, in the previous examples, the syntax of the
declaration of the <code>arr</code> and <code>third_element</code> variables looks similar to the one
of tables presented in the previous section. That's not a coincidence: to
create a variable or modify the value of an existing one, you send a table
containing all the variables you want to declare or change to the current
context, which is denoted by <code>~</code>. Consider the following example:</p>

<pre><code>~:pi -&gt; 3.14159
~:circumference -&gt; ~pi * 2 * 1.5
</code></pre>

<p>In the first line, you're simply sending <code>:pi -&gt; 3.14159</code> (a table) to <code>~</code>,
which is the block's context (or scope) -- and also usually a table. Then, to
access the <code>pi</code> variable, as depicted in the second line, you just need to send
the <code>pi</code> symbol to the context.</p>

<h3>
<a id="arithmetic-and-comparison" class="anchor" href="#arithmetic-and-comparison" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arithmetic and Comparison</h3>

<p>As well as variables, arithmetic operations are also based in the message send
operation. Here's how arithmetic looks like in Rubberband:</p>

<pre><code>~:two_plus_two -&gt; 2 + 2
~:my_bmi -&gt; 93 / (1.8 * 1.8)
~:overweight -&gt; ~my_bmi &gt; 25
</code></pre>

<p>Messages in Rubberband do not have any parameters and any object can only
respond to one message at a time. However, it is possible to implement <em>curried
functions</em> -- that is, functions that return other functions -- to emulate
message parameters the way they work in Smalltalk or Self.</p>

<p>Knowing this, let's interpret the <code>2 + 2</code> expression: the <code>+</code> message is sent
to the <code>2</code> object -- it's important to note that, in Rubberband, <code>+</code> is just a
regular symbol, with no difference from a syntactic or semantic standpoint to,
say, <code>plus</code> or <code>my_bmi</code>. The response to that message is a function that gets
any number sent to it and answers that number plus 2. Then, we send <code>2</code> to the
returned function, getting a <code>4</code>. For simplicity, from now on, function objects
that are answers of symbol messages will be called <em>methods</em> -- for instance,
the object <code>2</code> has the <code>+</code> method, which accepts a number as a message.</p>

<p>Note that the operations in Rubberband do not have any precedence rules:
they're simply executed in left-to-right order. For instance, the expression
<code>1 + 2 * 3 + 4</code> evaluates to <code>13</code>, instead of <code>11</code>, as one might expect; to
evaluate it to the latter value, parentheses are needed, like this:
<code>1 + (2 * 3) + 4</code>.</p>

<p>Arithmetic comparison operations -- less than, greater than, etc. -- are also
methods of any number, going by the names of <code>&lt;</code>, <code>&gt;</code>, etc.. The difference is
that they result in a boolean object; in the example, the <code>overweight</code> variable
will be assigned <code>?1</code>, that is, true.</p>

<h3>
<a id="control-flow" class="anchor" href="#control-flow" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control Flow</h3>

<p>There are no special keywords to handle control flow in the core language:
control flow, just like other operations, is also done by sending messages --
this time, to the boolean objects. For example, following the example from the
previous subsection:</p>

<pre><code>~overweight?~ {
  %inspect_object i_am_overweight
} {
  %inspect_object i_am_fine
}
</code></pre>

<p>Any boolean object has the <code>?</code> method, which gets the context (this will be
explained later) and two <em>blocks</em> of code: the first one is the block which gets
executed if the boolean is <code>?1</code>; the second one, if it is <code>?0</code>. In other words,
the <code>?</code> method gets the context, the <code>{ %inspect_object i_am_overweight }</code>
block, and the <code>{ %inspect_object i_am_fine }</code> block (<code>%inspect_object</code> prints
out the string representation of an object).</p>

<p>Loops are not present in the core language, but they can be done through
recursion (as we're going to see in the next section) and they're also provided
by the standard library, which will be introduced later.</p>

<h2>
<a id="blocks" class="anchor" href="#blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blocks</h2>

<p>Blocks are briefly introduced in the beginning of the language introduction
section and used in the previous example. Here, they're going to be explained in
more detail.</p>

<p><em>Blocks</em> define a sequence of instructions, optionally containing a response
value. Here's an example of a block:</p>

<pre><code>~:factorial -&gt; {
  ~:n -&gt; $, self -&gt; @

  !~n == 0?~ {
    !1
  } {
    !~n * (~self~(~n - 1))
  }
}
</code></pre>

<p>This block contains a code that calculates the factorial of a number. Of course,
it still doesn't test if the received message is actually a number and not a
symbol or an array, for instance, but this isn't so important right now: as long
as the message is a natural number, it'll work. This example contains all
special symbols that can be used inside a block, which are:</p>

<ul>
<li>
<code>~</code>: This was already presented and it's the <em>context</em>, which is more or less
like the scope of the code.</li>
<li>
<code>$</code>: The <em>message</em> received by the block. In our example, this would be
the number for which we want to calculate the factorial.</li>
<li>
<code>@</code>: A reference to the block itself, thus, a <em>self-reference</em>.</li>
<li>
<code>!</code>: The exclamation mark defines the beggining of the <em>response expression</em>.
The expression, in this case, is an "if else" statement, which responds
the response of whichever block runs  -- either the "if" block or the "else"
one. Here, if the received number is <code>0</code>, it responds <code>1</code>; otherwise, it
responds <code>~n * (~self~(~n - 1))</code>.</li>
</ul>

<p>A bit more of detail is needed to understand what a context is. Blocks aren't
actually executable -- at least, not directly. To execute the code inside a
block, you need to <em>instance</em> it. A <em>block instance</em> is bound to an object until
the end of its lifetime -- <em>that</em> object is the context, that is, the object
which is represented by <code>~</code> inside the block. To create a new instance, you send
an object which you want to bind the block to -- that is, the context. So, for
instance, to calculate the factorial of some numbers using the code provided by
the block above, we could do the following:</p>

<pre><code>~:factorial_instance -&gt; ~factorial(:)
%inspect_object(~factorial 6)   # 720
%inspect_object(~factorial 10)  # 3628800
%inspect_object(~factorial 12)  # 479001600
</code></pre>

<p>First, we create a new instance of the <code>factorial</code> block bound to a new empty
table (which is used to store <code>n</code> inside the block). Then, in the following
lines, we send some numbers as messages to that instance -- which, as it's been
shown, are represented by <code>$</code> inside the block. One noteworthy difference
between <code>~</code> -- the context -- and <code>$</code> -- the message -- is that, while the
message may be different in each execution of the block instance, the context
<em>is the same object</em> in all of its executions; in other words, any changes
to the context are kept in the object after the block instance finishes
executing. This didn't have an effect in the previous example, but consider
this:</p>

<pre><code>~:add -&gt; { ~:x -&gt; ~x + $ !~x }
~:add_instance -&gt; ~add:x -&gt; 1
%inspect_object(~add_instance 5)  # 6
%inspect_object(~add_instance 6)  # 12
%inspect_object(~add_instance 7)  # 19
</code></pre>

<p><code>add</code> gets a number, adds it to the value of <code>x</code>, attributes the value to that
same variable and returns it. We, then, create an instance of it bound to the
block <code>:x -&gt; 1</code> -- setting the initial value of <code>x</code> as <code>1</code>. As we call the
instance again and again with new values, <code>x</code> keeps growing because the changes
we do to the context in one call -- that is, the incrementation of the value --
are still available in the next calls.</p>

<p>Going back to the factorial example, we can now understand why we have to pass a
context object to the <code>?</code> method:</p>

<pre><code>  !~n == 0?~ {
    !1
  } {
    !~n * (~self~(~n - 1))
  }
</code></pre>

<p>The two blocks sent to it (<code>{ !1 }</code> and <code>{ !~n * (~self~(~n - 1)) }</code>) are not
block instances and, thus, aren't bound to any context. That method, then, needs
a context to create an instance from one of those blocks to, then, execute it
properly. Since we're passing <code>~</code> as their context, they will run over the same
context of the <code>factorial</code> block; this means that will be able to directly
access and modify anything in the parent context -- that's why <code>n</code> and <code>self</code>
are accessible from inside the second block.</p>

<p>(TODO below: better wording) </p>

<p><code>@</code> -- which is attributed to <code>self</code> -- is the self-reference. In this case, it
is needed to do the recursive call to <code>factorial</code>. Suppose we send <code>2</code> to a
<code>factorial</code> instance. <code>~n == 0</code> will be false, so the block
<code>{ !~n * ~self~(~n - 1) }</code> will be called -- this block will first get the value
of <code>n</code>, then call the self-reference with <code>~n - 1</code>. Note that we have to call
<code>~self~(~n - 1)</code>; that's because the self-reference is a reference to the
<em>block</em>, not to the <em>current instance</em> of it. Then, we recursively calculate the
factorial of <code>2</code>.</p>

<p>A final note on why it was necessary to declare the <code>n</code> and <code>self</code> variables.
That's needed because blocks don't automatically bind to their parent scope, so
if we, instead, did:</p>

<pre><code>~:factorial -&gt; {
  !~n == 0?~ {
    !1
  } {
    !$ * (@~(~n - 1))
  }
}
</code></pre>

<p>the code wouldn't work as expected, since the <code>$</code>, in this case, would be the
message passed <em>to the else block</em>, which is <code>()</code>; since <code>()</code> has no <code>*</code> method,
this would result in a runtime error. Even if the runtime error didn't happen,
<code>@</code> is a reference to the else block, not to <code>factorial</code>; in this case, the
stopping condition would never be checked and the program would enter in an
endless loop.</p>

<h2>
<a id="object-metainformation-or-reflection" class="anchor" href="#object-metainformation-or-reflection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Metainformation (or Reflection)</h2>

<p>TODO</p>

<h2>
<a id="raising-runtime-errors" class="anchor" href="#raising-runtime-errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raising Runtime Errors</h2>

<p>In some situations, to prevent incorrect behavior, the programmer needs to be
able to raise an error and abort the execution of the program. In Rubberband,
the boolean object provides the <code>^</code> method for that. Let's take the factorial
example again:</p>

<pre><code>~:factorial -&gt; {
  ~:n -&gt; $, self -&gt; @

  !~n == 0?~ {
    !1
  } {
    !$ * (@~(~n - 1))
  }
}
</code></pre>

<p>TODO</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Rubberband maintained by <a href="https://github.com/romariorios">romariorios</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
