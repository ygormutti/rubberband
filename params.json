{"name":"Rubberband","tagline":"Rubberband: A small, flexible language","body":"# The Rubberband Programming Language\r\n\r\nThis manual is intended to cover the latest version of the Rubberband\r\nprogramming language.\r\n\r\n## Building\r\n\r\nTODO base this section in current README.md\r\n\r\n## Overview\r\n\r\nThis section will give an overview of the goals and the characteristics of\r\nRubberband.\r\n\r\n### Design Goals\r\n\r\nThe Rubberband programming language is an experimental programming language\r\ncreated with the main objective of being as customizable by the developer as\r\npossible. Currently, the main design goals of Rubberband are:\r\n\r\n - **Core minimalism**: having _just a few basic elements_ instead of putting many\r\n features inside the core of the language makes it easier to build its features\r\n -- and the ones needed by the developer -- from the ground up, avoiding\r\n the redundancy of core language constructs.\r\n - **Orthogonality**: to provide the developer the flexibility for them to\r\n customize the language, it needs _allow composition_ between most elements of\r\n the language _in a way that makes sense_.\r\n - **Explicitness**: hidden or implicit elements or mechanisms in the language\r\n creates elements which, being out of reach from the runtime, cannot be\r\n directly customized -- thus, _explicitness increases the customizability of\r\n the language_.\r\n - **Conciseness**: although making a language concise solely to save keystrokes\r\n is considered a bad idea, since it may hurt readability, too much verbosity\r\n may also make the code hard to follow. Since the language is supposed to\r\n be explicit, many basic expressions will be visible in the code -- _making all\r\n these expressions too long leads to verbose code_, which can sacrifice\r\n readability more than conciseness. Aside from that, avoiding to use reserved\r\n words like \"if\", \"for\", \"while\" and others in favor of symbols like \"$\", \"@\",\r\n \"~\", etc. leaves room for the developer use the former for their own purposes.\r\n - **Freedom (and responsibility) to the developer**: the core Rubberband\r\n language intends to define as little policies and follow as little conventions\r\n as possible, because one of its goals is to _give the developer the ability to\r\n define their own conventions and policies_. This comes from the idea defining\r\n coding style, conventions, the design patterns in use and other kinds of\r\n project policies is a job of the _framework_ not one of the language, which\r\n should only be concerned in providing the constructs necessary to express\r\n those policies. That's why **minimalism** is also one of its core design\r\n goals: the core language is intended to provide a flexible foundation from\r\n which developers can develop their own frameworks, and having core features\r\n beyond the very basic will interfere with that.\r\n \r\nThere can be many more considerations on the design goals of Rubberband, but\r\nthose described above are enough to give an idea of why the language is like\r\nit is.\r\n\r\n### Characteristics\r\n\r\nNow that the design goals have been set, the actual characteristics of the\r\nlatest implementation will be described. Rubberband is:\r\n\r\n - **Purely object-oriented**: object-orientation is a concept which needs no\r\n introduction. However, _pure_ in this context means that every value in the\r\n language is an object. There are some languages in which this isn't the case,\r\n i.e. not all values are objects -- namely, _C++_ and _Java_. That's why this\r\n distinction is made.\r\n - **Message-based**: unlike many object-oriented languages, though --\r\n languages like _C++_, _Java_, etc. --, Rubberband is based on _message passing_\r\n instead of function calling. This makes it more similar to _Smalltalk_ and\r\n other languages which inherited this characteristic from it, like _Object C_\r\n and _Ruby_, for instance. But, unlike Smalltalk, messages do not have\r\n arguments attached to them in Rubberband. More on that later.\r\n - **Classless**: One more thing that sets Rubberband apart from Smalltalk,\r\n though, is that it doesn't have classes -- at least, not as a concept built in\r\n the language. Most object-oriented languages implement a class vs instance or\r\n object duality, that is, every object is necessarily an instance of a class --\r\n which may or may not be an object itself, depending on the language. In\r\n Rubberband, though, objects are standalone and don't need a class to exist --\r\n although the programmer can inquire on what _type_ of object it's dealing\r\n with. In that regard, Rubberband is closer to languages like _Self_, _Lua_,\r\n _Javascript_, _Io_, etc.. Languages like those are also referred to as\r\n _prototype-based_ languages.\r\n - **Reflexive**: All of the basic objects of the language offer reflection\r\n capabilities which enable the developer to query metainformation about an\r\n object; they can query the type of the object and if a given message is valid.\r\n - **Duck-typed**: Duck typing is a concept common in dynamic languages\r\n like _Python_ and _Ruby_. Like in those languages, in Rubberband, if an object\r\n behaves like you want it to in the context you're using, then, for all\r\n practical intents, it's the object you want. Without duck typing, the\r\n programmer is required to check if the type of the object is the right type.\r\n \r\n## Language Presentation\r\n\r\nThe previous section only passed by the features of the Rubberband, comparing\r\nthem with similar features in other languages. This section will present the\r\nlanguage and show its features on their own.\r\n\r\n### Objects\r\n\r\nAs seen before, Rubberband is a purely object-oriented, message-based,\r\nclassless, reflexive, duck typed, experimental programming language. As a\r\npurely object-oriented language, the _object_ is everywhere in the program.\r\nThe basic objects present in the language are:\r\n\r\n - **Numbers**: `10`, `200.555`, `-3`, `0`\r\n - **Symbols**, used to name variables, functions, operations, fields, etc..\r\n Basically, identifiers: `a`, `while`, `+`, etc.\r\n - **The empty object**, denoted `()`, used to indicate the absence of a value\r\n - **Booleans**: `?1` and `?0` (true and false, respectively)\r\n - **Arrays**. They start with `|`, are separated by commas and accept any\r\n object as an element -- but are not resizable: `|10, 20, 30`,\r\n `|a, 10, (|10, 20, 30), ?1`\r\n - **Tables**, which map symbols to functions. They start with `:`, followed\r\n by the symbol-object pairs, separated by commas: `:a -> 10, b -> 20, c -> 30`,\r\n `:yes -> ?1, twelve -> 12`,\r\n `:list -> (|2, 3, 5, 7), table -> (:happy -> ?1, age -> 25)`\r\n - **Blocks** of code. They are first-class citizens in Rubberband, so, just\r\n like arrays or a numbers, they can be put inside a table, an array, etc..\r\n They're enclosed between curly braces, whithin which the code is defined;\r\n currently, the code contained inside a Rubberband script file defines a block\r\n object, the only difference being the lack of curly braces. More details on\r\n blocks will be given in the following section.\r\n\r\n### Messages and answers\r\n\r\nRubberband is a message-based message. This means that the programmer gets\r\ninformation and modifies the state of an object by sending messages to it.\r\nA message to an object can be any other object; to send a message, the\r\nprogrammer just needs to put the message at the side of the object.\r\n\r\nFor example, suppose you store an array in a variable called `arr` like this:\r\n\r\n    ~:arr -> |10, 20, 30, 40\r\n\r\nArrays are zero-indexed in rubberband; so, to get the third element in the\r\narray -- which is 30 --, you would send the number `2` to the variable `arr`:\r\n\r\n    ~:third_element -> ~arr 2\r\n\r\nIn the above example, the message `2` is being sent to the variable `arr`.\r\nAs a reaction to receiving this message, the array gives an _answer_, which is,\r\nin this case, the third element of the array. There are two ways in which an\r\nobject can react to a message: it either gives an answer or it causes a runtime\r\nerror if the object doesn't respond to that message. For example, if you sent\r\n`4` instead of `2` to `arr`, since that index is out of range, that would\r\ngenerate a runtime error (TODO runtime error message here?).\r\n\r\nOf course, to send a second message to the answer of a message send, just place\r\nthe second message at the right side of the first one, and the same for any\r\nsubsequent messages. For example:\r\n\r\n    ~:nested -> 1, (|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13), 14\r\n    ~:number -> ~nested 1 2 3 4\r\n\r\nLet's interpret the above expression step by step: first, the number `1` is sent\r\nto `nested` -- the answer is the second element of the array, that is,\r\n`|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13`. Then, to that object, the\r\nnumber `2` is sent, to which the third element -- that is,\r\n`|4, 5, 6, (|7, 8, 9, 10, 11), 12` -- is given as the answer. From that, the\r\narray `|7, 8, 9, 10, 11` is given as an answer to the message `3`, to which,\r\nfinally, the message `4` is sent, giving is the value of the full expression:\r\n`11`, the fifth element of the array.\r\n\r\nThe message send is the only operation in Rubberband. Anything -- arithmetic,\r\ncontrol flow, accessing array elements, and other operations -- is done by\r\nsending messages to objects. Here are some examples on how that works.\r\n\r\n#### Variable assignment and access\r\n\r\nThe message send is the only operation in the language, so, even when the\r\nprogramming is, say, creating or accessing the value of a variable, they are\r\nsending a message to an object.\r\n\r\nYou might have noticed that, in the previous examples, the syntax of the\r\ndeclaration of the `arr` and `third_element` variables looks similar to the one\r\nof tables presented in the previous section. That's not a coincidence: to\r\ncreate a variable or modify the value of an existing one, you send a table\r\ncontaining all the variables you want to declare or change to the current\r\ncontext, which is denoted by `~`. Consider the following example:\r\n\r\n    ~:pi -> 3.14159\r\n    ~:circumference -> ~pi * 2 * 1.5\r\n\r\nIn the first line, you're simply sending `:pi -> 3.14159` (a table) to `~`,\r\nwhich is the block's context (or scope) -- and also usually a table. Then, to\r\naccess the `pi` variable, as depicted in the second line, you just need to send\r\nthe `pi` symbol to the context.\r\n\r\n#### Arithmetic and Comparison\r\n\r\nAs well as variables, arithmetic operations are also based in the message send\r\noperation. Here's how arithmetic looks like in Rubberband:\r\n\r\n    ~:two_plus_two -> 2 + 2\r\n    ~:my_bmi -> 93 / (1.8 * 1.8)\r\n    ~:overweight -> ~my_bmi > 25\r\n\r\nMessages in Rubberband do not have any parameters and any object can only\r\nrespond to one message at a time. However, it is possible to implement _curried\r\nfunctions_ -- that is, functions that return other functions -- to emulate\r\nmessage parameters the way they work in Smalltalk or Self.\r\n\r\nKnowing this, let's interpret the `2 + 2` expression: the `+` message is sent\r\nto the `2` object; it's important to note that, in Rubberband, `+` is just a\r\nregular symbol, with no difference from a syntactic or semantic standpoint to,\r\nsay, `plus` or `my_bmi`. The response to that message is a function that gets\r\nany number sent to it and answers that number plus 2. Then, we send `2` to the\r\nreturned function, getting a `4`.\r\n\r\nNote that the operations in Rubberband do not have any precedence rules:\r\nthey're simply executed in left-to-right order. For instance, the expression\r\n`1 + 2 * 3 + 4` evaluates to `13`, instead of `11`, as one might expect; to\r\nevaluate it to the latter value, parentheses are needed, like this:\r\n`1 + (2 * 3) + 4`.\r\n\r\nArithmetic comparison operations -- less than, greater than, etc. -- work in a\r\nsimilar way to that. The difference is that they result in a boolean object; in\r\nthe example, the `overweight` variable will be assigned `?1`, that is, true.\r\n\r\n#### Control Flow\r\n\r\nThere are no special keywords to handle control flow in the core language:\r\ncontrol flow, just like other operations, is also done by sending messages --\r\nthis time, to the boolean objects. For example, following the example from the\r\nprevious subsection:\r\n\r\n    ~overweight?~ {\r\n      %inspect_object i_am_overweight\r\n    } {\r\n      %inspect_object i_am_fine\r\n    }\r\n\r\nAny boolean object responds to the `?` message, getting the context (this will\r\nbe explained later) and two _blocks_ of code: the first one is the block which\r\ngets executed if the boolean is `?1`; the second one, if it is `?0`. In other\r\nwords, `?` gets sent to `~overweight`; then the context gets sent to the\r\nresponse of that, then `{ %inspect_object i_am_overweight }` is sent; then,\r\nfinally, `{ %inspect_object i_am_fine }` (`%inspect_object` prints out the\r\nstring representation of an object).\r\n\r\nLoops are not present in the core language, but they're provided by the standard\r\nlibrary, which will be introduced later.\r\n\r\n### Blocks\r\n\r\nBlocks are briefly introduced in the beginning of the language introduction\r\nsection and used in the previous example. Here, they're going to be explained in\r\nmore detail.\r\n\r\n_Blocks_ define a sequence of instructions, optionally containing a response\r\nvalue. Here's an example of a block:\r\n\r\n    ~:factorial -> {\r\n      ~:n -> $\r\n      \r\n      !~n == 0?~ {\r\n        !1\r\n      } {\r\n        !~n * (@~(~n - 1))\r\n      }\r\n    }\r\n\r\nThis block contains a code that calculates the factorial of a number. Of course,\r\nit still doesn't test if the received message is actually a number and not a\r\nsymbol or an array, for instance, but this isn't so important right now: as long\r\nas the message is a natural number, it'll work. This example contains all\r\nspecial symbols that can be used inside a block, which are:\r\n\r\n - `~`: This was already presented and it's the _context_, which is more or less\r\n like the scope of the code.\r\n - `$`: The _message_ received by the block. In our example, this would be\r\n the number for which we want to calculate the factorial.\r\n - `@`: A reference to the block itself, thus, a _self-reference_.\r\n - `!`: The exclamation mark defines the beggining of the _response expression_.\r\n The expression, in this case, is an \"if else\" statement, which responds\r\n the response of whichever block runs  -- either the \"if\" block or the \"else\"\r\n one. Here, if the received number is `0`, it responds `1`; otherwise, it\r\n responds `~n * (@~(~n - 1))`.\r\n\r\nA bit more of detail is needed to understand what a context is. Blocks aren't\r\nactually executable -- at least, not directly. To execute the code inside a\r\nblock, you need to _instance_ it. A _block instance_ is bound to an object until\r\nthe end of its lifetime -- _that_ object is the context, that is, the object\r\nwhich is represented by `~` inside the block. To create a new instance, you send\r\nan object which you want to bind the block to -- that is, the context. So, for\r\ninstance, to calculate the factorial of some numbers using the code provided by\r\nthe block above, we could do the following:\r\n\r\n    ~:factorial_instance -> ~factorial(:)\r\n    %inspect_object(~factorial 6)   # 720\r\n    %inspect_object(~factorial 10)  # 3628800\r\n    %inspect_object(~factorial 12)  # 479001600\r\n\r\nFirst, we create a new instance of the `factorial` block bound to a new empty\r\ntable (which is used to store `n` inside the block). Then, in the following\r\nlines, we send some numbers as messages to that instance -- which, as it's been\r\nshown, are represented by `$` inside the block. One noteworthy difference\r\nbetween `~` -- the context -- and `$` -- the message -- is that, while the\r\nmessage may be different in each execution of the block instance, the context\r\n_is the same object_ in all of its executions; in other words, any changes\r\nto the context are kept in the object after the block instance finishes\r\nexecuting. This didn't have an effect in the previous example, but consider\r\nthis:\r\n\r\n    ~:add -> { ~:x -> ~x + $ !~x }\r\n    ~:add_instance -> ~add:x -> 1\r\n    %inspect_object(~add_instance 5)  # 6\r\n    %inspect_object(~add_instance 6)  # 12\r\n    %inspect_object(~add_instance 7)  # 19\r\n\r\n`add` gets a number, adds it to the value of `x`, attributes the value to that\r\nsame variable and returns it. We, then, create an instance of it bound to the\r\nblock `:x -> 1` -- setting the initial value of `x` as `1`. As we call the\r\ninstance again and again with new values, `x` keeps growing because the changes\r\nwe do to the context in one call -- that is, the incrementation of the value --\r\nare still available in the next calls.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}