{"name":"Rubberband","tagline":"Rubberband: A small, flexible language","body":"### RUBBERBAND\r\n## What's this?\r\nRubberband is a small experimental programming language aiming to be simple and self-extensible. The current version is by no means a final version, there's still a lot of stuff missing, but it's functional and playable with.\r\n\r\n## How does it work?\r\nRubberband is object-oriented, assuming the following definition of _object_:\r\n\r\n> An object is an entity which reacts to messages by answering a result and changing its internal state. Both the message and the result are also objects.\r\n\r\nTo spawn a new object, the language makes some _literals_ available, which can be used standalone, or in conjunction with other literals. Everything else is done based on sending messages. For instance, the expression `1 + 2` consists of three literals: two numbers (`1` and `2`) and a symbol (`+`). The symbol `+` is sent to `1` and, then, the number `2` is sent to the answer of `1 +`, returning `3`.\r\n\r\n# Literals\r\nThe current literal types are available in Rubberband:\r\n* the empty object: `()`\r\n* number: `12`\r\n* symbol: `haha`\r\n* array: `|a, b, c` (or, optionally, `|[a, b, c]`)\r\n* table: `:a -> 10, b -> 20, c -> 30` (or, optionally, `|[a -> 10, b -> 20, c -> 30]`)\r\n* block: `{ !$ * $ }`\r\n* message: `$`\r\n* context: `~`\r\n* self-ref: `@`\r\n\r\n# Sending messages\r\nThe syntax to send messages is to simply place the message at the right side of the object:\r\n```\r\n|[a, b, c] 10\r\n```\r\nThe message `10` is being sent to the array `|[a, b, c]`. Note that the brackets are needed to indicate where the array ends: otherwise, if we had, say `|a, b, c 10`, the message `10` would be sent to the symbol `c`, which is not valid to do.\r\n\r\nThe sending messages operation is left associative, meaning that `1 + 2 + 3` is equivalent to `((((1 +) 2) +) 3)`.\r\n\r\n## What can it do?\r\nRight now, the literals and basic objects are mostly implemented, but strings, input and a lot of other stuff are missing. There's a print function, but it's more like an object inspector than anything else. There are a few functional examples at codeexamples.\r\n\r\n# Factorial\r\n```\r\n# The context (~) is usually a table or behaves like one\r\n# To modify a table, you simply need to send another table\r\n# containing the fields you wanna change (e.g.: if the\r\n# context evaluates to :[a -> 10], sending it :[b -> 20] as\r\n# a message will change it to :[a -> 10, b -> 20])\r\n# In the case below, we're \"declaring\" a new block as fac\r\n# in the current context\r\n~:fac -> {\r\n    # $ is the message received by the block\r\n    # ~ is the context of the current instance\r\n    # @ is a self-reference to this block\r\n    #\r\n    # n and fac have to be declared outside the else block\r\n    # because, inside them, they would be message and self-ref\r\n    # of that block.\r\n    # \r\n    # @~ means the current block is being instantiated with\r\n    # the current context. A block literal isn't executable,\r\n    # because the context is still yet to be defined -- only\r\n    # block instances are executable.\r\n    ~:n -> $, fac -> @~\r\n\r\n    # ! indicates the return statement\r\n    # Below, we have the equivalent of an if statement on\r\n    # Rubberband. As we know, ~ usually is a table or behaves\r\n    # like one. Sending a symbol to a table will retrieve the\r\n    # object in that index (for instance, :[a -> 10, b -> 20] b\r\n    # returns 20). In the case below, we get the value of n\r\n    # stored above, which is the same as $. (~n < 1) is a\r\n    # comparison operation and will return a boolean. The ?\r\n    # method of booleans receives the context (~, in the case\r\n    # below), the if block and the else block, respectively.\r\n    !~n < 1?~ {\r\n        !1\r\n    } {\r\n        # Classic recursion. The parentheses are needed because, as\r\n        # said above, the send message operation is left associative,\r\n        # and something like ~fac ~n - 1 would mean\r\n        # (((((~ fac) ~) n) -) 1), clearly not what the user intended\r\n        !~n * (~fac(~n - 1))\r\n    }\r\n}:[]\r\n# ~fac is then instantiated with an empty table as a context\r\n\r\n# Will print 3628800\r\n~print(~fac 10)\r\n```\r\n\r\n## Compiling\r\n```\r\ngit clone https://github.com/romariorios/rubberband\r\ncd rubberband\r\ncmake .\r\nmake\r\ncd rbbs\r\n./rbbs your_program.rbb\r\n```\r\n\r\n## Final word\r\nOh god what am I doing","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}