{"name":"Rubberband","tagline":"Rubberband: A small, flexible language","body":"Rubberband is a very minimalistic and customizable experimental programming\r\nlanguage. This manual introduces the language's goals and characteristics and,\r\nthen, presents it in more detail. This document tries to aim at the newest\r\nversion of Rubberband, but the language is not finished yet and it is constantly\r\nchanging, so, at the moment you're reading this, the document may be outdated\r\nwhen compared to the actual implementation -- so beware.\r\n\r\n# Building\r\n\r\nThe current project consists of the core library `librubberband` and the\r\nreference interpreter `rbbs` (stands for **r**ub**b**er**b**and **s**cript).\r\nThroughout the entirety of this manual, it is assumed that all examples are ran\r\nas scripts from the `rbbs` program.\r\n\r\n## Dependencies\r\n\r\nCurrently, the dependencies to build Rubberband are:\r\n\r\n- CMake (>= 2.8)\r\n- Make\r\n- g++ and gcc (>= 4.8) or clang (>= 3.3)\r\n\r\nNo extra dependencies are needed. Note that it's possible that it works in a\r\ndifferent configuration -- e.g., a newer version of clang or gcc --, but it has\r\nnever been tested.\r\n\r\n## Compiling rbbs\r\n\r\nIf you just want to build and run `rbbs`, from inside the `src` subdirectory of\r\nthe repository, run:\r\n\r\n    cmake . && make\r\n\r\nThe `rbbs` executable will be found at the `rbbs` subdir and then you can just\r\nuse it, passing the .rbb script as an argument. You can find examples in the\r\n`codeexamples` directory in the repository -- there are two at the moment of\r\nthis writing.\r\n\r\nFor more info on how to use CMake, check out its own documentation.\r\n\r\n## Running tests\r\n\r\nYou can also run the tests of the `librubberband` library. There's a\r\n`runtests.sh` script inside the `src/test` dir, which can be run from any fairly\r\nrecent version of Bash. The following variables are used:\r\n\r\n- `CXX`: The c++ compiler\r\n- `CXX_FLAGS` (default: `\"-g -O0\"` when CXX is either g++ or clang++): Flags\r\npassed to the compiler \r\n- `THREADS` (default: 1): Number of threads of the compilation process\r\n- `TESTS` (default: all): Tests which will be run\r\n- `RUBBERBAND_SRC` (default: `$PWD/../core`): Directory of rubberband's core\r\nlibrary source code\r\n\r\n# Language Overview\r\n\r\nThis section will give an overview of the goals and the characteristics of\r\nRubberband.\r\n\r\n## Design Goals\r\n\r\nThe Rubberband programming language is an experimental programming language\r\ncreated with the main objective of being as customizable by the developer as\r\npossible. Currently, the main design goals of Rubberband are:\r\n\r\n - **Core minimalism**: having _just a few basic elements_ instead of putting many\r\n features inside the core of the language makes it easier to build its features\r\n -- and the ones needed by the developer -- from the ground up, avoiding\r\n the redundancy of core language constructs.\r\n - **Orthogonality**: to provide the developer the flexibility for them to\r\n customize the language, it needs _allow composition_ between most elements of\r\n the language _in a way that makes sense_.\r\n - **Explicitness**: hidden or implicit elements or mechanisms in the language\r\n creates elements which, being out of reach from the runtime, cannot be\r\n directly customized -- thus, _explicitness increases the customizability of\r\n the language_.\r\n - **Conciseness**: although making a language concise solely to save keystrokes\r\n is considered a bad idea, since it may hurt readability, too much verbosity\r\n may also make the code hard to follow. Since the language is supposed to\r\n be explicit, many basic expressions will be visible in the code -- _making all\r\n these expressions too long leads to verbose code_, which can sacrifice\r\n readability more than conciseness. Aside from that, avoiding to use reserved\r\n words like \"if\", \"for\", \"while\" and others in favor of symbols like \"$\", \"@\",\r\n \"~\", etc. leaves room for the developer use the former for their own purposes.\r\n - **Freedom (and responsibility) to the developer**: the core Rubberband\r\n language intends to define as little policies and follow as little conventions\r\n as possible, because one of its goals is to _give the developer the ability to\r\n define their own conventions and policies_. This comes from the idea defining\r\n coding style, conventions, the design patterns in use and other kinds of\r\n project policies is a job of the _framework_ not one of the language, which\r\n should only be concerned in providing the constructs necessary to express\r\n those policies. That's why **minimalism** is also one of its core design\r\n goals: the core language is intended to provide a flexible foundation from\r\n which developers can develop their own frameworks, and having core features\r\n beyond the very basic will interfere with that.\r\n \r\nThere can be many more considerations on the design goals of Rubberband, but\r\nthose described above are enough to give an idea of why the language is like\r\nit is.\r\n\r\n## Characteristics\r\n\r\nNow that the design goals have been set, the actual characteristics of the\r\nlatest implementation will be described. Rubberband is:\r\n\r\n - **Purely object-oriented**: object-orientation is a concept which needs no\r\n introduction. However, _pure_ in this context means that every value in the\r\n language is an object. There are some languages in which this isn't the case,\r\n i.e. not all values are objects -- namely, _C++_ and _Java_. That's why this\r\n distinction is made.\r\n - **Message-based**: unlike many object-oriented languages, though --\r\n languages like _C++_, _Java_, etc. --, Rubberband is based on _message passing_\r\n instead of function calling. This makes it more similar to _Smalltalk_ and\r\n other languages which inherited this characteristic from it, like _Object C_\r\n and _Ruby_, for instance. But, unlike Smalltalk, messages do not have\r\n arguments attached to them in Rubberband. More on that later.\r\n - **Classless**: One more thing that sets Rubberband apart from Smalltalk,\r\n though, is that it doesn't have classes -- at least, not as a concept built in\r\n the language. Most object-oriented languages implement a class vs instance or\r\n object duality, that is, every object is necessarily an instance of a class --\r\n which may or may not be an object itself, depending on the language. In\r\n Rubberband, though, objects are standalone and don't need a class to exist --\r\n although the programmer can inquire on what _type_ of object it's dealing\r\n with. In that regard, Rubberband is closer to languages like _Self_, _Lua_,\r\n _Javascript_, _Io_, etc.. Languages like those are also referred to as\r\n _prototype-based_ languages.\r\n - **Reflexive**: All of the basic objects of the language offer reflection\r\n capabilities which enable the developer to query metainformation about an\r\n object; they can query the type of the object and if a given message is valid.\r\n - **Duck-typed**: Duck typing is a concept common in dynamic languages\r\n like _Python_ and _Ruby_. Like in those languages, in Rubberband, if an object\r\n behaves like you want it to in the context you're using, then, for all\r\n practical intents, it's the object you want. Without duck typing, the\r\n programmer is required to check if the type of the object is the right type.\r\n \r\n# Language Presentation\r\n\r\nThe previous section only passed by the features of the Rubberband, comparing\r\nthem with similar features in other languages. This section will present the\r\nlanguage and show its features on their own.\r\n\r\n## Objects\r\n\r\nAs seen before, Rubberband is a purely object-oriented, message-based,\r\nclassless, reflexive, duck typed, experimental programming language. As a\r\npurely object-oriented language, the _object_ is everywhere in the program.\r\nThe basic objects present in the language are:\r\n\r\n - **Numbers**: `10`, `200.555`, `-3`, `0`\r\n - **Symbols**, used to name variables, functions, operations, fields, etc..\r\n Basically, identifiers: `a`, `while`, `+`, etc.\r\n - **The empty object**, denoted `()`, used to indicate the absence of a value\r\n - **Booleans**: `?1` and `?0` (true and false, respectively)\r\n - **Arrays**. They start with `|`, are separated by commas and accept any\r\n object as an element -- but are not resizable: `|10, 20, 30`,\r\n `|a, 10, (|10, 20, 30), ?1`\r\n - **Tables**, which map symbols to functions. They start with `:`, followed\r\n by the symbol-object pairs, separated by commas: `:a -> 10, b -> 20, c -> 30`,\r\n `:yes -> ?1, twelve -> 12`,\r\n `:list -> (|2, 3, 5, 7), table -> (:happy -> ?1, age -> 25)`\r\n - **Blocks** of code. They are first-class citizens in Rubberband, so, just\r\n like arrays or a numbers, they can be put inside a table, an array, etc..\r\n They're enclosed between curly braces, whithin which the code is defined;\r\n currently, the code contained inside a Rubberband script file defines a block\r\n object, the only difference being the lack of curly braces. More details on\r\n blocks will be given in the following section.\r\n\r\n## Messages and answers\r\n\r\nRubberband is a message-based message. This means that the programmer gets\r\ninformation and modifies the state of an object by sending messages to it.\r\nA message to an object can be any other object; to send a message, the\r\nprogrammer just needs to put the message at the side of the object.\r\n\r\nFor example, suppose you store an array in a variable called `arr` like this:\r\n\r\n    ~:arr -> |10, 20, 30, 40\r\n\r\nArrays are zero-indexed in rubberband; so, to get the third element in the\r\narray -- which is 30 --, you would send the number `2` to the variable `arr`:\r\n\r\n    ~:third_element -> ~arr 2\r\n\r\nIn the above example, the message `2` is being sent to the variable `arr`.\r\nAs a reaction to receiving this message, the array gives an _answer_, which is,\r\nin this case, the third element of the array. There are two ways in which an\r\nobject can react to a message: it either gives an answer or it causes a runtime\r\nerror if the object doesn't respond to that message. For example, if you sent\r\n`4` instead of `2` to `arr`, since that index is out of range, that would\r\ngenerate a runtime error:\r\n\r\n    terminate called after throwing an instance of 'rbb::in_statement_error'\r\n      what(): In statement \"~ arr 4\": When sending message 4 to object (|10, 20, 30, 40): Message not recognized\r\n\r\nOf course, to send a second message to the answer of a message send, just place\r\nthe second message at the right side of the first one, and the same for any\r\nsubsequent messages. For example:\r\n\r\n    ~:nested -> 1, (|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13), 14\r\n    ~:number -> ~nested 1 2 3 4\r\n\r\nLet's interpret the above expression step by step: first, the number `1` is sent\r\nto `nested` -- the answer is the second element of the array, that is,\r\n`|2, 3, (|4, 5, 6, (|7, 8, 9, 10, 11), 12), 13`. Then, to that object, the\r\nnumber `2` is sent, to which the third element -- that is,\r\n`|4, 5, 6, (|7, 8, 9, 10, 11), 12` -- is given as the answer. From that, the\r\narray `|7, 8, 9, 10, 11` is given as an answer to the message `3`, to which,\r\nfinally, the message `4` is sent, giving is the value of the full expression:\r\n`11`, the fifth element of the array.\r\n\r\nThe message send is the only operation in Rubberband. Anything -- arithmetic,\r\ncontrol flow, accessing array elements, and other operations -- is done by\r\nsending messages to objects. Here are some examples on how that works.\r\n\r\n### Variable assignment and access\r\n\r\nThe message send is the only operation in the language, so, even when the\r\nprogramming is, say, creating or accessing the value of a variable, they are\r\nsending a message to an object.\r\n\r\nYou might have noticed that, in the previous examples, the syntax of the\r\ndeclaration of the `arr` and `third_element` variables looks similar to the one\r\nof tables presented in the previous section. That's not a coincidence: to\r\ncreate a variable or modify the value of an existing one, you send a table\r\ncontaining all the variables you want to declare or change to the current\r\ncontext, which is denoted by `~`. Consider the following example:\r\n\r\n    ~:pi -> 3.14159\r\n    ~:circumference -> ~pi * 2 * 1.5\r\n\r\nIn the first line, you're simply sending `:pi -> 3.14159` (a table) to `~`,\r\nwhich is the block's context (or scope) -- and also usually a table. Then, to\r\naccess the `pi` variable, as depicted in the second line, you just need to send\r\nthe `pi` symbol to the context.\r\n\r\n### Arithmetic and Comparison\r\n\r\nAs well as variables, arithmetic operations are also based in the message send\r\noperation. Here's how arithmetic looks like in Rubberband:\r\n\r\n    ~:two_plus_two -> 2 + 2\r\n    ~:my_bmi -> 93 / (1.8 * 1.8)\r\n    ~:overweight -> ~my_bmi > 25\r\n\r\nMessages in Rubberband do not have any parameters and any object can only\r\nrespond to one message at a time. However, it is possible to implement _curried\r\nfunctions_ -- that is, functions that return other functions -- to emulate\r\nmessage parameters the way they work in Smalltalk or Self.\r\n\r\nKnowing this, let's interpret the `2 + 2` expression: the `+` message is sent\r\nto the `2` object -- it's important to note that, in Rubberband, `+` is just a\r\nregular symbol, with no difference from a syntactic or semantic standpoint to,\r\nsay, `plus` or `my_bmi`. The response to that message is a function that gets\r\nany number sent to it and answers that number plus 2. Then, we send `2` to the\r\nreturned function, getting a `4`. For simplicity, from now on, function objects\r\nthat are answers of symbol messages will be called _methods_ -- for instance,\r\nthe object `2` has the `+` method, which accepts a number as a message.\r\n\r\nNote that the operations in Rubberband do not have any precedence rules:\r\nthey're simply executed in left-to-right order. For instance, the expression\r\n`1 + 2 * 3 + 4` evaluates to `13`, instead of `11`, as one might expect; to\r\nevaluate it to the latter value, parentheses are needed, like this:\r\n`1 + (2 * 3) + 4`.\r\n\r\nArithmetic comparison operations -- less than, greater than, etc. -- are also\r\nmethods of any number, going by the names of `<`, `>`, etc.. The difference is\r\nthat they result in a boolean object; in the example, the `overweight` variable\r\nwill be assigned `?1`, that is, true.\r\n\r\n### Control Flow\r\n\r\nThere are no special keywords to handle control flow in the core language:\r\ncontrol flow, just like other operations, is also done by sending messages --\r\nthis time, to the boolean objects. For example, following the example from the\r\nprevious subsection:\r\n\r\n    ~overweight?~ {\r\n      %inspect_object i_am_overweight\r\n    } {\r\n      %inspect_object i_am_fine\r\n    }\r\n\r\nAny boolean object has the `?` method, which gets the context (this will be\r\nexplained later) and two _blocks_ of code: the first one is the block which gets\r\nexecuted if the boolean is `?1`; the second one, if it is `?0`. In other words,\r\nthe `?` method gets the context, the `{ %inspect_object i_am_overweight }`\r\nblock, and the `{ %inspect_object i_am_fine }` block (`%inspect_object` prints\r\nout the string representation of an object).\r\n\r\nLoops are not present in the core language, but they can be done through\r\nrecursion (as we're going to see in the next section) and they're also provided\r\nby the standard library, which will be introduced later.\r\n\r\n## Blocks\r\n\r\nBlocks are briefly introduced in the beginning of the language introduction\r\nsection and used in the previous example. Here, they're going to be explained in\r\nmore detail.\r\n\r\n_Blocks_ define a sequence of instructions, optionally containing a response\r\nvalue. Here's an example of a block:\r\n\r\n    ~:factorial -> {\r\n      ~:n -> $, self -> @\r\n      \r\n      !~n == 0?~ {\r\n        !1\r\n      } {\r\n        !~n * (~self~(~n - 1))\r\n      }\r\n    }\r\n\r\nThis block contains a code that calculates the factorial of a number. Of course,\r\nit still doesn't test if the received message is actually a number and not a\r\nsymbol or an array, for instance, but this isn't so important right now: as long\r\nas the message is a natural number, it'll work. This example contains all\r\nspecial symbols that can be used inside a block, which are:\r\n\r\n - `~`: This was already presented and it's the _context_, which is more or less\r\n like the scope of the code.\r\n - `$`: The _message_ received by the block. In our example, this would be\r\n the number for which we want to calculate the factorial.\r\n - `@`: A reference to the block itself, thus, a _self-reference_.\r\n - `!`: The exclamation mark defines the beggining of the _response expression_.\r\n The expression, in this case, is an \"if else\" statement, which responds\r\n the response of whichever block runs  -- either the \"if\" block or the \"else\"\r\n one. Here, if the received number is `0`, it responds `1`; otherwise, it\r\n responds `~n * (~self~(~n - 1))`.\r\n\r\nA bit more of detail is needed to understand what a context is. Blocks aren't\r\nactually executable -- at least, not directly. To execute the code inside a\r\nblock, you need to _instance_ it. A _block instance_ is bound to an object until\r\nthe end of its lifetime -- _that_ object is the context, that is, the object\r\nwhich is represented by `~` inside the block. To create a new instance, you send\r\nan object which you want to bind the block to -- that is, the context. So, for\r\ninstance, to calculate the factorial of some numbers using the code provided by\r\nthe block above, we could do the following:\r\n\r\n    ~:factorial_instance -> ~factorial(:)\r\n    %inspect_object(~factorial 6)   # 720\r\n    %inspect_object(~factorial 10)  # 3628800\r\n    %inspect_object(~factorial 12)  # 479001600\r\n\r\nFirst, we create a new instance of the `factorial` block bound to a new empty\r\ntable (which is used to store `n` inside the block). Then, in the following\r\nlines, we send some numbers as messages to that instance -- which, as it's been\r\nshown, are represented by `$` inside the block. One noteworthy difference\r\nbetween `~` -- the context -- and `$` -- the message -- is that, while the\r\nmessage may be different in each execution of the block instance, the context\r\n_is the same object_ in all of its executions; in other words, any changes\r\nto the context are kept in the object after the block instance finishes\r\nexecuting. This didn't have an effect in the previous example, but consider\r\nthis:\r\n\r\n    ~:add -> { ~:x -> ~x + $ !~x }\r\n    ~:add_instance -> ~add:x -> 1\r\n    %inspect_object(~add_instance 5)  # 6\r\n    %inspect_object(~add_instance 6)  # 12\r\n    %inspect_object(~add_instance 7)  # 19\r\n\r\n`add` gets a number, adds it to the value of `x`, attributes the value to that\r\nsame variable and returns it. We, then, create an instance of it bound to the\r\nblock `:x -> 1` -- setting the initial value of `x` as `1`. As we call the\r\ninstance again and again with new values, `x` keeps growing because the changes\r\nwe do to the context in one call -- that is, the incrementation of the value --\r\nare still available in the next calls.\r\n\r\nGoing back to the factorial example, we can now understand why we have to pass a\r\ncontext object to the `?` method:\r\n\r\n      !~n == 0?~ {\r\n        !1\r\n      } {\r\n        !~n * (~self~(~n - 1))\r\n      }\r\n\r\nThe two blocks sent to it (`{ !1 }` and `{ !~n * (~self~(~n - 1)) }`) are not\r\nblock instances and, thus, aren't bound to any context. That method, then, needs\r\na context to create an instance from one of those blocks to, then, execute it\r\nproperly. Since we're passing `~` as their context, they will run over the same\r\ncontext of the `factorial` block; this means that will be able to directly\r\naccess and modify anything in the parent context -- that's why `n` and `self`\r\nare accessible from inside the second block.\r\n\r\n(TODO below: better wording) \r\n\r\n`@` -- which is attributed to `self` -- is the self-reference. In this case, it\r\nis needed to do the recursive call to `factorial`. Suppose we send `2` to a\r\n`factorial` instance. `~n == 0` will be false, so the block\r\n`{ !~n * ~self~(~n - 1) }` will be called -- this block will first get the value\r\nof `n`, then call the self-reference with `~n - 1`. Note that we have to call\r\n`~self~(~n - 1)`; that's because the self-reference is a reference to the\r\n_block_, not to the _current instance_ of it. Then, we recursively calculate the\r\nfactorial of `2`.\r\n\r\nA final note on why it was necessary to declare the `n` and `self` variables.\r\nThat's needed because blocks don't automatically bind to their parent scope, so\r\nif we, instead, did:\r\n\r\n    ~:factorial -> {\r\n      !~n == 0?~ {\r\n        !1\r\n      } {\r\n        !$ * (@~(~n - 1))\r\n      }\r\n    }\r\n\r\nthe code wouldn't work as expected, since the `$`, in this case, would be the\r\nmessage passed _to the else block_, which is `()`; since `()` has no `*` method,\r\nthis would result in a runtime error. Even if the runtime error didn't happen,\r\n`@` is a reference to the else block, not to `factorial`; in this case, the\r\nstopping condition would never be checked and the program would enter in an\r\nendless loop.\r\n\r\n## Object Metainformation\r\n\r\nMetainformation -- or reflection -- is contextual information about the object\r\nitself. _Any_ object provides metainfo; the methods used to acquired that\r\ninformation are `<<` and `<<?`. Respectively, they provide information about\r\nwhat messages an object responds and about the object's type -- or, rather, the\r\ninterfaces it conforms to.\r\n\r\n### The `<<` Method\r\n\r\nThe first method, `<<`, can get any object as its message and answers a boolean\r\n-- `?1` if the receiver responds to the message, `?0` otherwise. This is\r\nimportant because, if an object gets a message it doesn't respond to, it will\r\nraise a runtime error. For example:\r\n\r\n    ~:plus_1 -> {\r\n      !$ + 1\r\n    }()\r\n\r\nHere, we create a block and instance it in the same expression, then save it in\r\nthe `plus_1` variable -- we instance it with `()` because the context is not\r\nneeded in this case. `plus_1` obviously expects a number as its message, since\r\nthe method `+` is being called with a number. But if we, for instance, call it\r\nwith a symbol, like this:\r\n\r\n    %inspect_object(~plus_1 five)\r\n\r\nthe runtime result will be:\r\n\r\n    terminate called after throwing an instance of 'rbb::in_statement_error'\r\n      what():  In statement \"$ + 1\": When sending message + to object five: Message not recognized\r\n\r\nA runtime error happened because `five` is a symbol and symbols do not respond\r\nto the `+` method. To prevent this from happening, we can check if the message\r\nhas that method using `<<`. This time, we have to set an empty table as the\r\ncontext, since we're defining a variable inside the block:\r\n\r\n    ~:checked_plus_1 -> {\r\n      ~:msg -> $\r\n      \r\n      !~msg << +?~ {\r\n        !~msg + 1\r\n      } {\r\n        !()\r\n      }\r\n    }(:)\r\n    \r\n    %inspect_object(~checked_plus_1 five)\r\n    %inspect_object(~checked_plus_1 10)\r\n\r\nNow, if we pass a message that does not have the `+` method -- like `five`, for\r\nexample --, `checked_plus_1` will answer `()` instead of raising a runtime\r\nerror, not interrupting the execution of the program:\r\n\r\n    ()\r\n    11\r\n\r\n`<<` can also be used to check if an index is inside the bounds of an array or\r\nif a given symbol is defined in a table:\r\n\r\n    %inspect_object((|10, 20, 30) << 3)                 # ?0\r\n    %inspect_object((:a -> 10, b -> 20, c -> 30) << b)  # ?1\r\n\r\n### The `<<?` method\r\n\r\nThe second method, `<<?`, is used to gather information about the type of an\r\nobject or about the interfaces it conforms to. When an object conforms to some\r\ninterface, it means that it implements some behaviors expected from the objects\r\nwhich conform to it. For instance, if an object conforms to the `[0]` interface,\r\nit means that it responds properly to all number-related messages -- in other\r\nwords, it is a number.\r\n\r\nGoing back to `checked_plus_1`, we can see a flaw in its implementation:\r\n\r\n    %inspect_object(~checked_plus_1|10, 20, 30)\r\n    \r\nExecuting it we get this:\r\n\r\n    terminate called after throwing an instance of 'rbb::in_statement_error'\r\n      what():  In statement \"~ msg + 1\": When sending message 1 to object [unknown data]: Array expected\r\n\r\nThis error happens because, inside `checked_plus_1`, we only check if the\r\nmessage contains the `+` method. An array, which does contain the `+` method,\r\nwill pass that check, but the `+` method of the array does not mean \"sum\", but\r\nrather \"concatenate\", and it expects another array, not a number -- which is why\r\nthe runtime error is raised.\r\n\r\nTODO WIP\r\n\r\n## Raising Runtime Errors\r\n\r\nIn some situations, to prevent incorrect behavior, the programmer needs to be\r\nable to raise an error and abort the execution of the program. In Rubberband,\r\nthe boolean object provides the `^` method for that. Let's take the factorial\r\nexample again:\r\n\r\n    ~:factorial -> {\r\n      ~:n -> $, self -> @\r\n      \r\n      !~n == 0?~ {\r\n        !1\r\n      } {\r\n        !$ * (@~(~n - 1))\r\n      }\r\n    }\r\n\r\nTODO\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}